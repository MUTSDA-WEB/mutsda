/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */
// biome-ignore-all lint: generated file

Object.defineProperty(exports, "__esModule", { value: true });

const {
   PrismaClientKnownRequestError,
   PrismaClientUnknownRequestError,
   PrismaClientRustPanicError,
   PrismaClientInitializationError,
   PrismaClientValidationError,
   getPrismaClient,
   sqltag,
   empty,
   join,
   raw,
   skip,
   Decimal,
   Debug,
   DbNull,
   JsonNull,
   AnyNull,
   NullTypes,
   makeStrictEnum,
   Extensions,
   warnOnce,
   defineDmmfProperty,
   Public,
   getRuntime,
   createParam,
} = require("./runtime/client.js");

const Prisma = {};

exports.Prisma = Prisma;
exports.$Enums = {};

/**
 * Prisma Client JS version: 7.3.0
 * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
 */
Prisma.prismaVersion = {
   client: "7.3.0",
   engine: "9d6ad21cbbceab97458517b147a6a09ff43aa735",
};

Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError;
Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError;
Prisma.PrismaClientInitializationError = PrismaClientInitializationError;
Prisma.PrismaClientValidationError = PrismaClientValidationError;
Prisma.Decimal = Decimal;

/**
 * Re-export of sql-template-tag
 */
Prisma.sql = sqltag;
Prisma.empty = empty;
Prisma.join = join;
Prisma.raw = raw;
Prisma.validator = Public.validator;

/**
 * Extensions
 */
Prisma.getExtensionContext = Extensions.getExtensionContext;
Prisma.defineExtension = Extensions.defineExtension;

/**
 * Shorthand utilities for JSON filtering
 */
Prisma.DbNull = DbNull;
Prisma.JsonNull = JsonNull;
Prisma.AnyNull = AnyNull;

Prisma.NullTypes = NullTypes;

const path = require("path");

/**
 * Enums
 */
exports.Prisma.TransactionIsolationLevel = makeStrictEnum({
   ReadUncommitted: "ReadUncommitted",
   ReadCommitted: "ReadCommitted",
   RepeatableRead: "RepeatableRead",
   Serializable: "Serializable",
});

exports.Prisma.UserScalarFieldEnum = {
   userID: "userID",
   role: "role",
   email: "email",
   phoneNumber: "phoneNumber",
   userName: "userName",
   password: "password",
};

exports.Prisma.EventScalarFieldEnum = {
   eventID: "eventID",
   title: "title",
   description: "description",
   imageURL: "imageURL",
   createdAt: "createdAt",
   updatedAt: "updatedAt",
   eventStartDate: "eventStartDate",
   eventEndDate: "eventEndDate",
   userId: "userId",
};

exports.Prisma.SortOrder = {
   asc: "asc",
   desc: "desc",
};

exports.Prisma.QueryMode = {
   default: "default",
   insensitive: "insensitive",
};
exports.Role = exports.$Enums.Role = {
   user: "user",
   admin1: "admin1",
   admin2: "admin2",
   elder1: "elder1",
   elder2: "elder2",
   elder3: "elder3",
   churchLeader: "churchLeader",
   headDeacon: "headDeacon",
   headDeaconness: "headDeaconness",
   sabbathSchool: "sabbathSchool",
   treasurer: "treasurer",
   clerk: "clerk",
   alo: "alo",
   amo: "amo",
   prophecy: "prophecy",
   stewardship: "stewardship",
   music: "music",
   welfare: "welfare",
   development: "development",
   communication: "communication",
};

exports.Prisma.ModelName = {
   User: "User",
   Event: "Event",
};
/**
 * Create the Client
 */
const config = {
   previewFeatures: [],
   clientVersion: "7.3.0",
   engineVersion: "9d6ad21cbbceab97458517b147a6a09ff43aa735",
   activeProvider: "postgresql",
   inlineSchema:
      '// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?\n// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init\n\ngenerator client {\n  provider = "prisma-client-js"\n  output   = "./generated"\n}\n\ndatasource db {\n  provider = "postgresql"\n}\n\nenum Role {\n  user           @map("USER")\n  admin1         @map("ADMIN1")\n  admin2         @map("ADMIN2")\n  elder1         @map("ELDER1")\n  elder2         @map("ELDER2")\n  elder3         @map("ELDER3")\n  churchLeader   @map("CHURCHLEADER")\n  headDeacon     @map("HEADDEACON")\n  headDeaconness @map("HEADDEACONNESS")\n  sabbathSchool  @map("SABBATHSCHOOL")\n  treasurer      @map("TREASURER")\n  clerk          @map("CLERK")\n  alo            @map("ALO")\n  amo            @map("AMO")\n  prophecy       @map("PROPHECY")\n  stewardship    @map("STEWARDSHIP")\n  music          @map("MUSIC")\n  welfare        @map("WELFARE")\n  development    @map("DEVELOPMENT")\n  communication  @map("COMMUNICATION")\n}\n\nmodel User {\n  userID      String @id @unique @default(uuid()) @map("id") // @id means primary key, @unique means the value must be unique, @default(val) sets a default value \'val\' uuid() generates a random unique value\n  role        Role   @unique\n  email       String @unique\n  phoneNumber Int    @map("phone_number")\n  userName    String @unique @map("username")\n  password    String @unique\n\n  // a user can create many events \n  events Event[] @relation("UserEvents")\n\n  @@map("user_table")\n}\n\nmodel Event {\n  eventID        String   @id @default(uuid()) @map("event_id")\n  title          String\n  description    String\n  imageURL       String   @map("image_url")\n  createdAt      DateTime @default(now()) @map("created_at")\n  updatedAt      DateTime @updatedAt @map("updated_at")\n  eventStartDate DateTime @map("event_start_date")\n  eventEndDate   DateTime @map("event_end_date")\n\n  // each event must have a foreign key of its creator\n  userId String\n  user   User   @relation("UserEvents", fields: [userId], references: [userID])\n\n  @@map("event_table")\n}\n',
};

config.runtimeDataModel = JSON.parse(
   '{"models":{"User":{"fields":[{"name":"userID","kind":"scalar","type":"String","dbName":"id"},{"name":"role","kind":"enum","type":"Role"},{"name":"email","kind":"scalar","type":"String"},{"name":"phoneNumber","kind":"scalar","type":"Int","dbName":"phone_number"},{"name":"userName","kind":"scalar","type":"String","dbName":"username"},{"name":"password","kind":"scalar","type":"String"},{"name":"events","kind":"object","type":"Event","relationName":"UserEvents"}],"dbName":"user_table"},"Event":{"fields":[{"name":"eventID","kind":"scalar","type":"String","dbName":"event_id"},{"name":"title","kind":"scalar","type":"String"},{"name":"description","kind":"scalar","type":"String"},{"name":"imageURL","kind":"scalar","type":"String","dbName":"image_url"},{"name":"createdAt","kind":"scalar","type":"DateTime","dbName":"created_at"},{"name":"updatedAt","kind":"scalar","type":"DateTime","dbName":"updated_at"},{"name":"eventStartDate","kind":"scalar","type":"DateTime","dbName":"event_start_date"},{"name":"eventEndDate","kind":"scalar","type":"DateTime","dbName":"event_end_date"},{"name":"userId","kind":"scalar","type":"String"},{"name":"user","kind":"object","type":"User","relationName":"UserEvents"}],"dbName":"event_table"}},"enums":{},"types":{}}',
);
defineDmmfProperty(exports.Prisma, config.runtimeDataModel);
config.compilerWasm = {
   getRuntime: async () => require("./query_compiler_fast_bg.js"),
   getQueryCompilerWasmModule: async () => {
      const { Buffer } = require("node:buffer");
      const { wasm } = require("./query_compiler_fast_bg.wasm-base64.js");
      const queryCompilerWasmFileBytes = Buffer.from(wasm, "base64");

      return new WebAssembly.Module(queryCompilerWasmFileBytes);
   },
   importName: "./query_compiler_fast_bg.js",
};

const PrismaClient = getPrismaClient(config);
exports.PrismaClient = PrismaClient;
Object.assign(exports, Prisma);
